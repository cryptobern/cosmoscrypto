# Elliptic Curve Point Encoding
*taken from [ieee_std_1363-2000](https://gitlab.inf.unibe.ch/crypto/2021.cosmoscrypto/-/blob/master/standards/ieee_std_1363-2000.pdf)*<br>

In this standard we find the following 6 primitives defined:
- integer to bit string (I2BSP)
- bit string to integer (BS2IP)
- bit string to octet string (BS2OSP)
- octet string to bit string (OS2BSP)
- elliptic curve point to octet string (EC2OSP)
- octet string to elliptic curve point (OS2ECP)

## I2BSP / BS2IP

Integer shall be written in its unique l-digit representation base 2 

$`x = x_{l-1}2^{l-1} + x_{l-2}2^{l-2} + ... + x_l2 + x_0`$

Where $`x_i`$ is either 0 or 1. Then let the bit $`b_i`$ have the value $`x_{l-i}`$ for $`1 <= i <= l`$. The bit string shall be $`b_1b_2...b_l`$ 

## BS2OSP / OS2BSP

To represent a bit string as an octet string, one simply pads enough zeroes on the left to make the number of bits a multiple of eight, and then breaks it up into octets. More precisely, a bit string 

## EC2OSP
There are two different ways to serialize elliptic curve points: Compressed and uncompressed. In the uncompressed form, both x and y coordinates of the EC point are stored, so the point is essentially a tuple $`(x_p, y_p)`$. In the compressed form, only the x-coordinate and an additional bit are stored. <br>
Compressed form: $`(x_p, ŷ_p), x_p`$ = x-coordinate, $`ŷ_p`$ a bit that's computed as follows: <br>

1. if the field size $`q`$ is an odd prime, then $`ŷ_p = y_p \mod 2`$ &nbsp; ($`y_p`$ = rightmost bit of $`y_p`$) 

1. if field size $`q`$ is a power of 2 and $`x_p = 0`$, then $`ŷ_p = 0`$ 

1. if the field size $`q`$ is a power of 2 and $`x_p \neq 0`$, then $`ŷ_p`$ is the rightmost bit of the field element $`y_px_p^{-1}`$ 

The actual representation of a EC point `P` in bytes looks like the following: PO = PC || X || Y with PC being a single octet of the form `00000UCŶ`, where <br>

- `U` is 1 if the format is uncompressed or hybrid, 0 otherwise 

- `C` is 1 if the format is compressed or hybrid, 0 otherwise  

- `Ŷ` is equal to the bit $`ŷ_p`$ if the format is compressed or hybrid, 0 otherwise 

- `X` is the octet string of length $`\lceil \log_{256} {q} \rceil`$ representing $`x_p`$ according to FE2OSP <br> 

- `Y` is the octet string of length $`\lceil \log_{256} {q} \rceil`$ representing $`y_p`$ of P according to FE2OSP if the format is uncompressed or hybrid; Y is an empty string if the format is compressed 

## OS2ECP
It takes the octet string and the field size q as inputs and outputs the
corresponding elliptic curve point, or “error.” It should use OS2FEP to get $`x_P`$ . It should use OS2FEP to get
$`y_P`$ if the format is uncompressed. It should use point decompression to get $`y_P`$ if the format is
compressed. It can get $`y_P`$ by either of these two means if the format is hybrid. It should output “error” in the
following cases:

- If the first octet is 00000000 and the octet string length is not 1
- If the first octet is 00000100, 00000110, or 00000111 and the octet string length is not
$`1 + 2 \lceil \log_{256}{q}\rceil `$
- If the first octet is 00000010, 00000011 and the octet string length is not $`1 + \lceil \log_{256}{q}\rceil `$
- If the first octet is any value other than the six values listed above
- If an invocation of OS2FEP outputs “error”
- If an invocation of the point decompression algorithm outputs “error”

NOTE: The first five bits of the first octet `PC` are reserved and may be used in future formats defined in an amendment
to, or in future version of, this standard. It is essential that they be set to zero and checked for zero in order to distinguish
this format from other formats.

## Decompression of y coordinates (prime case)
The following algorithm recovers the y coordinate of an elliptic curve point from its compressed form.
Input: A prime number p; an elliptic curve E defined modulo p; the x coordinate of a point (x, y) on E; the
compressed representation ỹ of the y coordinate
Output: The y coordinate of the point
1. Compute $`g := x^3 + ax + b \mod p`$.
2. Find a square root $`z`$ of $`g`$ modulo $`p`$ via A.2.5. If the output of A.2.5 is “no square roots exist,”
then return an error message and stop.
3. Let z̃ be the rightmost bit of z (in other words, $`z \mod 2`$).
4. If z̃ = ỹ , then y ← z, else y ← p – z.
5. Output $`y`$.
NOTE—When implementing the algorithm from A.2.5, the existence of modular square roots should be checked.
Otherwise, a value may be returned even if no modular square roots exist.

##  Decompression of y coordinates (binary case)
The following algorithm recovers the y coordinate of an elliptic curve point from its compressed form.
Input: A field GF (2^m ); an elliptic curve E defined over GF (2^m ); the x coordinate of a point (x, y) on E; the
compressed representation ỹ of the y coordinate
Output: The y coordinate of the point
1. If x = 0, then compute y :=
b via A.4.1 and go to step 7.
2. Compute the field element α := x 3 + ax 2 + b in GF (2 m ).
3. Compute the element β := α (x 2 ) –1 via A.4.4.
4. Find a field element z such that z 2 + z = β via A.4.7. If the output of A.4.7 is “no solutions
exist,” then return an error message and stop.
5. Let z̃ be the rightmost bit of z.
6. Compute y := (z + z̃ + ỹ ) x.
7. Output y.

NOTES
1—When implementing the algorithm from A.4.7, the existence of solutions to the quadratic equation should be
checked. Otherwise, a value may be returned even if no solutions exist.
2—If both coordinates are compressed, the x coordinate must be decompressed first and then the y coordinate
(see A.12.10).
